{"ast":null,"code":"import React, { useState, useEffect } from \"react\";\nimport { useRecoilTransactionObserver_UNSTABLE, useRecoilSnapshot, useGotoRecoilSnapshot } from \"recoil\";\nimport { formatFiberNodes } from \"./formatFiberNodes\"; // grabs isPersistedState from sessionStorage\n\nlet isPersistedState = sessionStorage.getItem(\"isPersistedState\"); // isRestored state disables snapshots from being recorded\n\nlet isRestoredState = false; // set default throttle to 70, throttle timer changes with every snapshot\n\nlet throttleTimer = 0;\nlet throttleLimit = 70;\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n  const {\n    root\n  } = props;\n  let nodes = null;\n\n  if (typeof props.nodes === \"object\" && !Array.isArray(props.nodes)) {\n    nodes = Object.values(props.nodes);\n  } else if (Array.isArray(props.nodes)) {\n    nodes = props.nodes;\n  }\n\n  console.log('index. js RecoilizeDebugger props.nodes: ', nodes);\n  const snapshot = useRecoilSnapshot();\n  console.log('index.js snapshot: ', snapshot); // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n\n  const [snapshots, setSnapshots] = useState([snapshot]); // const [isRestoredState, setRestoredState] = useState(false);\n\n  const gotoSnapshot = useGotoRecoilSnapshot();\n  const filteredSnapshot = {};\n\n  const currentTree = snapshot._store.getState().currentTree;\n\n  console.log('index.js snapshot._store: ', snapshot._store);\n  console.log('index.js snapshot._store.getState(): ', snapshot._store.getState());\n  console.log('index.js snapshot._store.getstate().currentTree', snapshot._store.getState().currentTree);\n  console.log('index.js snapshot.getNodes_UNSTABLE: ', snapshot.getNodes_UNSTABLE()); // Traverse all atoms and selector state nodes and get value\n\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents; // updated nodeDeps to fix 0.0.13 issue;\n\n    const nodeDeps = snapshot.getNodes_UNSTABLE();\n    const nodeToNodeSubscriptions = currentTree.nodeToNodeSubscriptions.get(node.key); // Construct node data structure for dev tool to consume\n\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps ? Array.from(nodeDeps) : [],\n      nodeToNodeSubscriptions: nodeToNodeSubscriptions ? Array.from(nodeToNodeSubscriptions) : []\n    };\n  });\n  console.log('index.js Filtered Snapshot: ', filteredSnapshot); // React lifecycle hook on re-render\n\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener(\"message\", onMessageReceived);\n\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot); // Post message to content script on every re-render of the developers application only if content script has started\n\n      sendWindowMessage(\"recordSnapshot\", devToolData);\n    } else {\n      isRestoredState = false;\n    } // Clears the window event listener.\n\n\n    return () => window.removeEventListener(\"message\", onMessageReceived);\n  }); // Listener callback for messages sent to windowf\n\n  const onMessageReceived = msg => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case \"contentScriptStarted\":\n        if (isPersistedState === \"false\" || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(filteredSnapshot);\n          const devToolData = createDevToolDataObject(initialFilteredSnapshot);\n          sendWindowMessage(\"moduleInitialized\", devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage(\"persistSnapshots\", null);\n        }\n\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n\n      case \"snapshotTimeTravel\":\n        timeTravelToSnapshot(msg);\n        break;\n\n      case \"persistState\":\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n\n      case \"throttleEdit\":\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n\n      default:\n        break;\n    }\n  }; // assigns or switches isPersistedState in sessionStorage\n\n\n  const switchPersistMode = () => {\n    if (isPersistedState === \"false\" || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem(\"isPersistedState\", true); // stores the length of current list of snapshots in sessionStorage\n\n      sessionStorage.setItem(\"persistedSnapshots\", snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem(\"isPersistedState\", false);\n    }\n  }; // function retreives length and fills snapshot array\n\n\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem(\"persistedSnapshots\");\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  }; // Sends window an action and payload message.\n\n\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage({\n      action,\n      payload\n    }, \"*\");\n  };\n\n  const createDevToolDataObject = filteredSnapshot => {\n    return {\n      filteredSnapshot: filteredSnapshot,\n      componentAtomTree: formatFiberNodes(root._reactRootContainer._internalRoot.current)\n    };\n  };\n\n  const formatAtomSelectorRelationship = filteredSnapshot => {\n    if (window.$recoilDebugStates && Array.isArray(window.$recoilDebugStates) && window.$recoilDebugStates.length) {\n      let snapObj = window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n\n      if (snapObj.hasOwnProperty(\"nodeDeps\")) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n\n      if (snapObj.hasOwnProperty(\"nodeToNodeSubscriptions\")) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n\n    return filteredSnapshot;\n  }; // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n\n\n  const timeTravelToSnapshot = async msg => {\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  }; // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n\n\n  useRecoilTransactionObserver_UNSTABLE(({\n    snapshot\n  }) => {\n    const now = new Date().getTime();\n\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n  return null;\n}","map":{"version":3,"sources":["/Users/jesusvargas/Documents/GitHub/recoil-paint/node_modules/recoilize/index.js"],"names":["React","useState","useEffect","useRecoilTransactionObserver_UNSTABLE","useRecoilSnapshot","useGotoRecoilSnapshot","formatFiberNodes","isPersistedState","sessionStorage","getItem","isRestoredState","throttleTimer","throttleLimit","RecoilizeDebugger","props","root","nodes","Array","isArray","Object","values","console","log","snapshot","snapshots","setSnapshots","gotoSnapshot","filteredSnapshot","currentTree","_store","getState","getNodes_UNSTABLE","forEach","node","index","type","__proto__","constructor","name","contents","getLoadable","nodeDeps","nodeToNodeSubscriptions","get","key","from","window","addEventListener","onMessageReceived","devToolData","createDevToolDataObject","sendWindowMessage","removeEventListener","msg","data","action","initialFilteredSnapshot","formatAtomSelectorRelationship","setProperIndexForPersistedState","timeTravelToSnapshot","switchPersistMode","parseInt","payload","value","setItem","length","retreived","snapshotsArray","Number","fill","postMessage","componentAtomTree","_reactRootContainer","_internalRoot","current","$recoilDebugStates","snapObj","hasOwnProperty","snapshotIndex","now","Date","getTime"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport {\n  useRecoilTransactionObserver_UNSTABLE,\n  useRecoilSnapshot,\n  useGotoRecoilSnapshot,\n} from \"recoil\";\nimport { formatFiberNodes } from \"./formatFiberNodes\";\n\n// grabs isPersistedState from sessionStorage\nlet isPersistedState = sessionStorage.getItem(\"isPersistedState\");\n\n// isRestored state disables snapshots from being recorded\nlet isRestoredState = false;\n\n// set default throttle to 70, throttle timer changes with every snapshot\nlet throttleTimer = 0;\nlet throttleLimit = 70;\n\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n\n  const { root } = props;\n\n  let nodes = null;\n\n  if (typeof props.nodes === \"object\" && !Array.isArray(props.nodes)) {\n    nodes = Object.values(props.nodes);\n  } else if (Array.isArray(props.nodes)) {\n    nodes = props.nodes;\n  }\n\n  console.log('index. js RecoilizeDebugger props.nodes: ', nodes);\n\n  const snapshot = useRecoilSnapshot();\n  \n  console.log('index.js snapshot: ', snapshot);\n  // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n  const [snapshots, setSnapshots] = useState([snapshot]);\n  // const [isRestoredState, setRestoredState] = useState(false);\n  const gotoSnapshot = useGotoRecoilSnapshot();\n\n  const filteredSnapshot = {};\n  const currentTree = snapshot._store.getState().currentTree;\n  console.log('index.js snapshot._store: ', snapshot._store);\n  console.log('index.js snapshot._store.getState(): ', snapshot._store.getState());\n  console.log('index.js snapshot._store.getstate().currentTree', snapshot._store.getState().currentTree);\n\n  console.log('index.js snapshot.getNodes_UNSTABLE: ', snapshot.getNodes_UNSTABLE());\n\n  // Traverse all atoms and selector state nodes and get value\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents;\n    // updated nodeDeps to fix 0.0.13 issue;\n    const nodeDeps = snapshot.getNodes_UNSTABLE();\n    const nodeToNodeSubscriptions = currentTree.nodeToNodeSubscriptions.get(\n      node.key\n    );\n\n    // Construct node data structure for dev tool to consume\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps ? Array.from(nodeDeps) : [],\n      nodeToNodeSubscriptions: nodeToNodeSubscriptions\n        ? Array.from(nodeToNodeSubscriptions)\n        : [],\n    };\n  });\n\n  console.log('index.js Filtered Snapshot: ', filteredSnapshot);\n\n  // React lifecycle hook on re-render\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener(\"message\", onMessageReceived);\n\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot);\n      // Post message to content script on every re-render of the developers application only if content script has started\n      sendWindowMessage(\"recordSnapshot\", devToolData);\n    } else {\n      isRestoredState = false;\n    }\n\n    // Clears the window event listener.\n    return () => window.removeEventListener(\"message\", onMessageReceived);\n  });\n\n  // Listener callback for messages sent to windowf\n  const onMessageReceived = (msg) => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case \"contentScriptStarted\":\n        if (isPersistedState === \"false\" || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(\n            filteredSnapshot\n          );\n          const devToolData = createDevToolDataObject(initialFilteredSnapshot);\n          sendWindowMessage(\"moduleInitialized\", devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage(\"persistSnapshots\", null);\n        }\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n      case \"snapshotTimeTravel\":\n        timeTravelToSnapshot(msg);\n        break;\n      case \"persistState\":\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n      case \"throttleEdit\":\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  // assigns or switches isPersistedState in sessionStorage\n  const switchPersistMode = () => {\n    if (isPersistedState === \"false\" || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem(\"isPersistedState\", true);\n\n      // stores the length of current list of snapshots in sessionStorage\n      sessionStorage.setItem(\"persistedSnapshots\", snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem(\"isPersistedState\", false);\n    }\n  };\n\n  // function retreives length and fills snapshot array\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem(\"persistedSnapshots\");\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  };\n\n  // Sends window an action and payload message.\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage(\n      {\n        action,\n        payload,\n      },\n      \"*\"\n    );\n  };\n\n  const createDevToolDataObject = (filteredSnapshot) => {\n    return {\n      filteredSnapshot: filteredSnapshot,\n      componentAtomTree: formatFiberNodes(\n        root._reactRootContainer._internalRoot.current\n      ),\n    };\n  };\n\n  const formatAtomSelectorRelationship = (filteredSnapshot) => {\n    if (\n      window.$recoilDebugStates &&\n      Array.isArray(window.$recoilDebugStates) &&\n      window.$recoilDebugStates.length\n    ) {\n      let snapObj =\n        window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n      if (snapObj.hasOwnProperty(\"nodeDeps\")) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n      if (snapObj.hasOwnProperty(\"nodeToNodeSubscriptions\")) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n    return filteredSnapshot;\n  };\n\n  // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n  const timeTravelToSnapshot = async (msg) => {\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  };\n\n  // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n  useRecoilTransactionObserver_UNSTABLE(({ snapshot }) => {\n    const now = new Date().getTime();\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}